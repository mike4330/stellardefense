<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Defense</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="mainWrapper">
        <div id="infoPanel">
            <div id="infoTop">
                <span id="scoreValue">0</span> | <span id="levelName">1 Alpha</span>
            </div>
            <div id="progressContainer">
                <div id="progressLabel">Enemies Remaining: <span id="enemiesRemaining">30</span></div>
                <div id="progressBar">
                    <div id="progressFill"></div>
                </div>
            </div>
        </div>
        <div id="gameContainer" style="position: relative;">
            <canvas id="gameCanvas" width="600" height="800"></canvas>
            <div id="instructions">Arrow keys to move • Space to shoot • P or ESC to pause • R to restart • Q to quit • H for high scores</div>
            <div id="startOverlay">
                <div id="gameTitle">STELLAR DEFENSE</div>
                <button id="startButton">START GAME</button>
                <button id="viewHighScoresButton">HIGH SCORES</button>
            </div>
            
            <!-- Game State Overlays -->
            <div id="pauseOverlay" class="game-overlay pause-overlay">
                <div class="main-text">PAUSED</div>
                <div class="sub-text">Press P or ESC to resume</div>
            </div>
            
            <div id="gameOverOverlay" class="game-overlay game-over-overlay">
                <div class="main-text">GAME OVER</div>
                <div class="score-text">Final Score: <span id="finalScore">000000</span></div>
                <div class="sub-text">Thanks for playing!</div>
                <div class="sub-text">Press R to restart</div>
            </div>
            
            <div id="levelTransitionOverlay" class="game-overlay level-transition-overlay">
                <div class="main-text">LEVEL COMPLETE!</div>
                <div class="level-text"><span id="completedLevelName">Level Name</span> cleared!</div>
                <div class="score-text">Score: <span id="transitionScore">000000</span></div>
                <div class="sub-text">Loading next level...</div>
            </div>
            
            <div id="victoryOverlay" class="game-overlay victory-overlay">
                <div class="main-text">VICTORY!</div>
                <div class="score-text">Final Score: <span id="victoryScore">000000</span></div>
                <div class="sub-text">All levels completed!</div>
                <div class="sub-text">Press R to restart</div>
            </div>
            
            <!-- High Score Entry Overlay -->
            <div id="highScoreEntryOverlay" class="game-overlay high-score-entry-overlay">
                <div class="main-text">NEW HIGH SCORE!</div>
                <div class="score-info">
                    Score: <span class="highlight" id="newHighScore">000000</span> | 
                    Level: <span class="highlight" id="newHighLevel">1</span>
                </div>
                <div class="name-input-container">
                    <label class="name-input-label" for="playerNameInput">Enter Your Name (8 characters max):</label>
                    <input type="text" id="playerNameInput" class="name-input" maxlength="8" placeholder="PLAYER">
                </div>
                <div class="high-score-buttons">
                    <button id="submitHighScore" class="high-score-btn primary">SUBMIT</button>
                    <button id="skipHighScore" class="high-score-btn">SKIP</button>
                </div>
            </div>
            
            <!-- High Scores Table Overlay -->
            <div id="highScoresOverlay" class="game-overlay high-scores-overlay">
                <div class="high-scores-header">HIGH SCORES</div>
                <div id="highScoresTable">
                    <!-- Table will be populated by JavaScript -->
                </div>
                <button id="closeHighScores" class="close-high-scores">CLOSE</button>
            </div>
        </div>
    </div>

    <script src="sound.js"></script>
    <script src="level_config.js"></script>
    <script src="visual_effects.js"></script>
    <script src="high_scores.js"></script>
    <script src="enemy_manager.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startOverlay = document.getElementById('startOverlay');
        const startButton = document.getElementById('startButton');
        
        // Initialize visual effects
        const visualEffects = new VisualEffects(canvas, ctx);
        
        // Initialize high score manager
        const highScoreManager = new HighScoreManager();
        
        // Initialize enemy manager
        const enemyManager = new EnemyManager(canvas, ctx, soundManager, visualEffects);
        
        // Game state
        const keys = {};
        let score = 0;
        let lastShot = 0;
        let shotsInBurst = 0;  // Track shots in current burst
        let lastBurstTime = 0; // Track when last burst started
        let canShoot = true;   // Track if we can shoot in current burst
        let paused = false;
        let enemiesDestroyed = 0;
        // Enemy tracking now handled by EnemyManager
        let gameWon = false;
        let gameQuit = false;
        let levelTransition = false;
        let gameStartTime = 0; // Initialize to 0, will be set when game starts
        let currentLevel = 1;
        let debugMode = false;
        let playerLives = 3;
        let playerInvulnerable = false;
        let playerInvulnerableTime = 0;
        let gameStarted = false;
        let highScoreChecked = false;  // Prevent multiple high score checks
        
        // Extra life system
        const extraLifeThresholds = [10000, 21000, 44100, 92610];
        let extraLifeIndex = 0;  // Track which threshold is next
        
        // Pause timing system
        let pauseStartTime = 0;
        let totalPausedTime = 0;
        
        // Level teleport system for debug mode
        let teleportInput = '';
        let teleportActive = false;
        
        // Spawn schedule system - now handled by EnemyManager
        
        // Current level config
        let enemyConfig = levelConfigs[currentLevel];
        
        // Enemy functions now handled by EnemyManager
        
        // Player ship
        const player = {
            x: canvas.width / 2 - 9,
            y: canvas.height - 55,
            width: 18,
            height: 18,
            speed: 5,
            velocityX: 0,  // Current x velocity
            velocityY: 0,  // Current y velocity
            maxSpeedX: 5,  // Maximum x speed
            maxSpeedY: 5,  // Maximum y speed
            accelerationX: 0.15,  // X acceleration factor for ease-in
            accelerationY: 0.15,  // Y acceleration factor for ease-in (lower = more noticeable ease)
            frictionX: 0.75,  // X friction for smooth stop
            frictionY: 0.75,  // Y friction for smooth stop
            respawnX: canvas.width / 2 - 9,  // Store respawn position
            respawnY: canvas.height - 55
        };
        
        // Game objects - enemies now managed by EnemyManager
        
        // Bullets array
        const bullets = [];
        
        // Enemy bullets array
        const enemyBullets = [];
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            // Initialize audio on first interaction
            if (!soundManager.audioContext) {
                soundManager.initAudio();
            }
            
            keys[e.code] = true;
            
            // Handle level teleport in debug mode
            if (debugMode && gameStarted && !paused) {
                if (e.key === 'j' && !teleportActive) {
                    // Start teleport input
                    teleportActive = true;
                    teleportInput = '';
                    console.log('Level teleport activated. Enter level number and press Enter...');
                    return;
                } else if (teleportActive) {
                    if (e.key === 'Enter') {
                        // Execute teleport
                        const targetLevel = parseInt(teleportInput);
                        if (!isNaN(targetLevel) && targetLevel > 0) {
                            teleportToLevel(targetLevel);
                        } else {
                            console.log('Invalid level number:', teleportInput);
                        }
                        teleportActive = false;
                        teleportInput = '';
                        return;
                    } else if (e.key === 'Escape') {
                        // Cancel teleport
                        console.log('Level teleport cancelled');
                        teleportActive = false;
                        teleportInput = '';
                        return;
                    } else if (e.key >= '0' && e.key <= '9') {
                        // Add digit to teleport input
                        teleportInput += e.key;
                        console.log('Teleport target:', teleportInput);
                        return;
                    } else if (e.key === 'Backspace') {
                        // Remove last digit
                        teleportInput = teleportInput.slice(0, -1);
                        console.log('Teleport target:', teleportInput || '(empty)');
                        return;
                    }
                    // For any other key during teleport input, ignore but don't cancel
                    return;
                }
            }
            
            if (e.code === 'KeyP' || e.code === 'Escape') {
                // Cancel teleport if escape is pressed
                if (teleportActive) {
                    console.log('Level teleport cancelled');
                    teleportActive = false;
                    teleportInput = '';
                    return;
                }
                
                // Handle pause/unpause with timing
                if (!paused) {
                    // Pausing the game
                    paused = true;
                    pauseStartTime = Date.now();
                } else {
                    // Unpausing the game
                    paused = false;
                    if (pauseStartTime > 0) {
                        totalPausedTime += Date.now() - pauseStartTime;
                        pauseStartTime = 0;
                    }
                }
            }
            
            if (e.code === 'KeyR') {
                restartGame();
            }
            
            if (e.code === 'KeyQ') {
                quitGame();
            }
            
            if (e.code === 'KeyD') {
                debugMode = !debugMode;  // Toggle debug mode
                if (debugMode) {
                    console.log('Debug mode enabled. Press j<levelnumber><enter> to teleport to a level');
                } else {
                    console.log('Debug mode disabled');
                    // Cancel any active teleport input
                    teleportActive = false;
                    teleportInput = '';
                }
            }
            
            if (e.code === 'KeyH') {
                highScoreManager.showHighScores();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Collision detection functions now in EnemyManager
        
        // Create explosion effect
        function createExplosion(x, y) {
            visualEffects.createExplosion(x, y, soundManager);
        }
        
        // Update score display
        function updateScore(points) {
            const oldScore = score;
            score += points;
            document.getElementById('scoreValue').textContent = score.toString().padStart(6, '0');
            
            // Check for extra life thresholds
            if (extraLifeIndex < extraLifeThresholds.length) {
                const threshold = extraLifeThresholds[extraLifeIndex];
                if (oldScore < threshold && score >= threshold) {
                    // Award extra life
                    playerLives++;
                    extraLifeIndex++;
                    
                    // Visual and audio feedback
                    console.log(`Extra life earned at ${threshold} points! Lives: ${playerLives}`);
                    soundManager.playSpawnSound(); // Use spawn sound for extra life (positive sound)
                    
                    // Could add a visual effect here later
                    createExplosion(player.x + player.width / 2, player.y + player.height / 2); // Temporary visual effect
                }
            }
        }
        
        // Update level display
        function updateLevelDisplay() {
            document.getElementById('levelName').textContent = enemyConfig.name;
        }
        
        // Update progress bar display
        function updateProgressBar() {
            const remaining = enemyConfig.global.maxEnemies - enemiesDestroyed;
            const progressPercentage = (enemiesDestroyed / enemyConfig.global.maxEnemies) * 100;
            
            document.getElementById('enemiesRemaining').textContent = remaining;
            document.getElementById('progressFill').style.width = progressPercentage + '%';
        }
        
        // Enemy creation and spawning now handled by EnemyManager
        
        // Restart game function
        function restartGame() {
            score = 0;
            enemiesDestroyed = 0;
            gameWon = false;
            gameQuit = false;
            levelTransition = false;
            paused = false;
            currentLevel = 1;
            playerLives = 3;
            playerInvulnerable = false;
            gameStartTime = Date.now();
            highScoreChecked = false;  // Reset high score check flag
            
            // Reset pause timing
            pauseStartTime = 0;
            totalPausedTime = 0;
            
            // Reset extra life tracking
            extraLifeIndex = 0;
            
            enemyConfig = levelConfigs[currentLevel];
            
            // Update visual effects level
            visualEffects.setCurrentLevel(currentLevel);
            
            // Initialize enemy manager for this level
            enemyManager.initializeLevel(enemyConfig);
            
            document.getElementById('scoreValue').textContent = score.toString().padStart(6, '0');
            updateLevelDisplay();
            updateProgressBar();
            
            player.x = player.respawnX;
            player.y = player.respawnY;
            
            bullets.length = 0;
            enemyBullets.length = 0;
            visualEffects.explosions.length = 0;
        }
        
        // Advance to next level
        function nextLevel() {
            currentLevel++;
            if (levelConfigs[currentLevel]) {
                enemyConfig = levelConfigs[currentLevel];
                enemiesDestroyed = 0;
                gameWon = false;
                levelTransition = false;
                gameStartTime = Date.now();
                
                // Reset pause timing for new level
                pauseStartTime = 0;
                totalPausedTime = 0;
                
                // Update visual effects level
                visualEffects.setCurrentLevel(currentLevel);
                
                // Initialize enemy manager for this level
                enemyManager.initializeLevel(enemyConfig);
                
                updateLevelDisplay();
                updateProgressBar();
                
                bullets.length = 0;
                enemyBullets.length = 0;
                visualEffects.explosions.length = 0;
            } else {
                gameWon = true;
                levelTransition = false;
            }
        }
        
        // Teleport to specific level (debug function)
        function teleportToLevel(targetLevel) {
            if (!debugMode) return; // Only allow in debug mode
            
            if (levelConfigs[targetLevel]) {
                currentLevel = targetLevel;
                enemyConfig = levelConfigs[currentLevel];
                enemiesDestroyed = 0;
                gameWon = false;
                levelTransition = false;
                gameStartTime = Date.now();
                
                // Reset pause timing for teleported level
                pauseStartTime = 0;
                totalPausedTime = 0;
                
                // Update visual effects level
                visualEffects.setCurrentLevel(currentLevel);
                
                // Initialize enemy manager for this level
                enemyManager.initializeLevel(enemyConfig);
                
                updateLevelDisplay();
                updateProgressBar();
                bullets.length = 0;
                enemyBullets.length = 0;
                visualEffects.explosions.length = 0;
                
                console.log(`Teleported to level ${targetLevel}: ${enemyConfig.name}`);
            } else {
                console.log(`Level ${targetLevel} does not exist`);
            }
        }
        
        // Shoot bullet
        function shootBullet() {
            const now = Date.now();
            
            // Reset burst if player hasn't fired for 2 seconds
            if (now - lastShot > 2000) {
                shotsInBurst = 0;
                canShoot = true;
            }
            
            // If we're in cooldown, check if it's been long enough
            if (shotsInBurst >= 5) {
                if (now - lastBurstTime < 550) { // 550ms cooldown
                    return;
                }
                // Reset burst if cooldown is over
                shotsInBurst = 0;
                canShoot = true;
            }
            
            // Only shoot if we're allowed to in this burst
            if (!canShoot) {
                return;
            }
            
            // Add delay between individual bullets in burst (85ms)
            if (shotsInBurst > 0 && now - lastShot < 85) {
                return;
            }
            
            bullets.push({
                x: player.x + player.width / 2 - 1,
                y: player.y,
                width: 2,
                height: 6,
                speed: 8
            });
            
            soundManager.playBulletSound();
            shotsInBurst++;
            lastShot = now;
            
            // If we've used all shots, start cooldown timer and prevent further shooting
            if (shotsInBurst >= 5) {
                canShoot = false;
                lastBurstTime = now;  // Start cooldown timer when burst completes
            }
        }
        
        // Update game state
        function update() {
            if (!gameStarted || paused || gameWon || levelTransition) return;
            
            // If game is quit, only update starfield
            if (gameQuit) {
                visualEffects.updateStarfield();
                return;
            }
            
            enemyManager.spawnEnemies(gameStartTime, totalPausedTime);
            
            // Handle player invulnerability
            if (playerInvulnerable) {
                const now = Date.now();
                if (now - playerInvulnerableTime > 2000) { // 2 seconds of invulnerability
                    playerInvulnerable = false;
                }
            }
            
            // Horizontal movement with ease-in
            let targetVelocityX = 0;
            if (keys['ArrowLeft'] && player.x > 0) {
                targetVelocityX = -player.maxSpeedX;
            }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
                targetVelocityX = player.maxSpeedX;
            }
            
            // Apply easing to x velocity
            if (targetVelocityX !== 0) {
                // Accelerate towards target velocity
                player.velocityX += (targetVelocityX - player.velocityX) * player.accelerationX;
            } else {
                // Apply friction when no input
                player.velocityX *= player.frictionX;
            }
            
            // Apply velocity to position
            player.x += player.velocityX;
            
            // Vertical movement with ease-in
            let targetVelocityY = 0;
            if (keys['ArrowUp'] && player.y > canvas.height / 2) {
                targetVelocityY = -player.maxSpeedY;
            }
            if (keys['ArrowDown'] && player.y < canvas.height - player.height) {
                targetVelocityY = player.maxSpeedY;
            }
            
            // Apply easing to y velocity
            if (targetVelocityY !== 0) {
                // Accelerate towards target velocity
                player.velocityY += (targetVelocityY - player.velocityY) * player.accelerationY;
            } else {
                // Apply friction when no input
                player.velocityY *= player.frictionY;
            }
            
            // Apply velocity to position
            player.y += player.velocityY;
            
            const now = Date.now();
            if (keys['Space']) {
                shootBullet();
            }
            
            // Update enemies using enemy manager
            enemyManager.updateEnemies(enemyBullets);
            
            // Check for collisions with player
            const enemies = enemyManager.getEnemies();
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                if (enemy.alive && !playerInvulnerable && enemyManager.checkEnhancedCollision(player, enemy)) {
                    handlePlayerDeath();
                }
            }
            
            for (let i = bullets.length - 1; i >= 0; i--) {
                // Handle deflected bullets with different movement
                if (bullets[i].deflected && bullets[i].vx !== undefined && bullets[i].vy !== undefined) {
                    bullets[i].x += bullets[i].vx;
                    bullets[i].y += bullets[i].vy;
                } else {
                    bullets[i].y -= bullets[i].speed;
                }
                
                let bulletHit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (enemy.alive && enemyManager.checkEnhancedCollision(bullets[i], enemy)) {
                        // Check if this is a type 4 enemy with active force field
                        if (enemy.type === 4 && enemy.forceField && enemy.forceField.active) {
                            // Deflect bullet instead of destroying enemy
                            const bulletCenterX = bullets[i].x + bullets[i].width / 2;
                            const bulletCenterY = bullets[i].y + bullets[i].height / 2;
                            const enemyCenterX = enemy.x + enemy.width / 2;
                            const enemyCenterY = enemy.y + enemy.height / 2;
                            
                            // Calculate deflection angle
                            const dx = bulletCenterX - enemyCenterX;
                            const dy = bulletCenterY - enemyCenterY;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            
                            if (length > 0) {
                                // Deflect bullet away from enemy center
                                const deflectionSpeed = 6;
                                bullets[i].vx = (dx / length) * deflectionSpeed;
                                bullets[i].vy = (dy / length) * deflectionSpeed;
                                bullets[i].deflected = true; // Mark as deflected to change behavior
                            }
                            
                            // Create small visual effect for deflection
                            for (let k = 0; k < 3; k++) {
                                visualEffects.explosions.push({
                                    x: bulletCenterX,
                                    y: bulletCenterY,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: (Math.random() - 0.5) * 2,
                                    life: 15,
                                    maxLife: 15
                                });
                            }
                            
                            break; // Don't destroy the bullet or enemy
                        } else {
                            // Normal collision - destroy enemy
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            const points = enemyManager.getEnemyPoints(enemy.type);
                            
                            updateScore(points);
                            enemy.alive = false;
                            enemiesDestroyed++;
                            updateProgressBar();
                            bullets.splice(i, 1);
                            bulletHit = true;
                            
                            enemyManager.removeDeadEnemies();
                            
                            if (enemiesDestroyed >= enemyConfig.global.maxEnemies) {
                                if (levelConfigs[currentLevel + 1]) {
                                    // Start level transition
                                    levelTransition = true;
                                    setTimeout(nextLevel, 2500); // 2.5 second pause
                                } else {
                                    // All levels complete - true victory
                                    gameWon = true;
                                }
                            }
                            
                            break;
                        }
                    }
                }
                
                if (bulletHit) continue;
                
                // Remove bullets that go off screen (normal bullets only go up, deflected can go anywhere)
                if (bullets[i].deflected) {
                    if (bullets[i].x < -10 || bullets[i].x > canvas.width + 10 || 
                        bullets[i].y < -10 || bullets[i].y > canvas.height + 10) {
                        bullets.splice(i, 1);
                    }
                } else {
                    if (bullets[i].y < 0) {
                        bullets.splice(i, 1);
                    }
                }
            }
            
            // Update enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // Check collision with player
                if (!playerInvulnerable && enemyManager.checkEnhancedCollision(bullet, player)) {
                    handlePlayerDeath();
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                // Remove bullet if it goes off screen
                if (bullet.x < -10 || bullet.x > canvas.width + 10 || 
                    bullet.y < -10 || bullet.y > canvas.height + 10) {
                    enemyBullets.splice(i, 1);
                }
            }
            
            // Update visual effects
            visualEffects.updateStarfield();
            visualEffects.updateExplosions();
        }
        
        // Draw everything
        function draw() {
            // Clear screen and draw starfield
            visualEffects.clearScreen();
            visualEffects.drawStarfield();
            
            // If game is quit, only show starfield and game over text
            if (gameQuit) {
                visualEffects.showOverlay('gameOver', { score });
                return;
            }
            
            // Level transition screen
            if (levelTransition) {
                visualEffects.showOverlay('levelTransition', { 
                    levelName: enemyConfig.name, 
                    score 
                });
                return;
            }
            
            // Draw game objects
            visualEffects.drawPlayer(player, playerInvulnerable);
            visualEffects.drawPlayerLives(playerLives);
            visualEffects.drawEnemies(enemyManager.getEnemies());
            visualEffects.drawBullets(bullets);
            visualEffects.drawEnemyBullets(enemyBullets);
            visualEffects.drawExplosions();
            
            // Only show debug info if debug mode is enabled
            if (debugMode) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'left';
                const enemies = enemyManager.getEnemies();
                const aliveEnemies = enemyManager.getAliveEnemiesCount();
                const remainingToKill = enemyConfig.global.maxEnemies - enemiesDestroyed;
                const currentTime = (Date.now() - gameStartTime - totalPausedTime) / 1000;
                const timeWindow = enemyConfig.global.spawnTimeWindow;
                const spawnInfo = enemyManager.getSpawnScheduleInfo();
                
                let debugY = canvas.height - 90;
                
                // Show teleport status if active
                if (teleportActive) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(`TELEPORT: j${teleportInput}_ (Enter to confirm, Esc to cancel)`, 10, debugY);
                    debugY += 15;
                    ctx.fillStyle = '#ffffff';
                }
                
                ctx.fillText(`DEBUG: Spawned: ${enemyManager.getTotalEnemiesCreated()}/${enemyConfig.global.maxEnemies}`, 10, debugY);
                ctx.fillText(`Schedule: ${spawnInfo.nextSpawnIndex}/${spawnInfo.totalScheduled} | Time: ${currentTime.toFixed(1)}s/${timeWindow}s`, 10, debugY + 15);
                ctx.fillText(`Alive: ${aliveEnemies} | Killed: ${enemiesDestroyed}`, 10, debugY + 30);
                ctx.fillText(`Remaining: ${remainingToKill}`, 10, debugY + 45);
                ctx.fillText(`Total Enemies Array: ${enemies.length}`, 10, debugY + 60);
                ctx.fillText(`Level: ${currentLevel} (${enemyConfig.name}) | j<num><enter> to teleport`, 10, debugY + 75);
                
                // Show force field status for type 4 enemies
                const type4Enemies = enemies.filter(e => e.alive && e.type === 4);
                if (type4Enemies.length > 0) {
                    const activeForceFields = [];
                    type4Enemies.forEach((enemy, index) => {
                        if (enemy.forceField && enemy.forceField.active) {
                            const timeRemaining = Math.max(0, enemy.forceField.duration - (Date.now() - enemy.forceField.activationStartTime)) / 1000;
                            activeForceFields.push(`#${enemies.indexOf(enemy)} (${timeRemaining.toFixed(1)}s)`);
                        }
                    });
                    
                    if (activeForceFields.length > 0) {
                        ctx.fillStyle = '#00ffff'; // Cyan color for force field info
                        ctx.fillText(`Force Fields Active: ${activeForceFields.join(', ')}`, 10, debugY + 90);
                        ctx.fillStyle = '#ffffff'; // Reset to white
                    } else {
                        ctx.fillStyle = '#888888'; // Gray for inactive
                        ctx.fillText(`Force Fields: None active (${type4Enemies.length} type-4 enemies present)`, 10, debugY + 90);
                        ctx.fillStyle = '#ffffff'; // Reset to white
                    }
                }
            }
            
            // Show overlay screens
            if (paused) {
                visualEffects.showOverlay('paused');
            } else if (gameWon) {
                visualEffects.showOverlay('victory', { score });
            } else if (!gameQuit && !levelTransition) {
                // Hide overlays when game is running normally
                visualEffects.hideAllOverlays();
            }
        }
        
        // Main game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        
        // Initialize game on start button click
        startButton.addEventListener('click', () => {
            if (!soundManager.audioContext) {
                soundManager.initAudio();
            }
            startOverlay.style.display = 'none';
            gameStarted = true;
            
            // Initialize game timing and enemy manager when game actually starts
            gameStartTime = Date.now();
            enemyManager.initializeLevel(enemyConfig);
        });
        
        // High scores button click
        document.getElementById('viewHighScoresButton').addEventListener('click', () => {
            // Hide start overlay when viewing high scores from start screen
            startOverlay.style.display = 'none';
            
            highScoreManager.showHighScores(() => {
                // Show start overlay again when high scores are closed
                if (!gameStarted) {
                    startOverlay.style.display = 'flex';
                }
            });
        });
        
        updateLevelDisplay();
        updateProgressBar();
        
        gameLoop();
        
        // Quit game function
        function quitGame() {
            const confirmed = confirm('Are you sure you want to quit the game?');
            if (confirmed) {
                checkForHighScore();
            }
        }
        
        // Check if current score qualifies for high score table
        function checkForHighScore() {
            // Prevent multiple high score checks in the same game session
            if (highScoreChecked) {
                finalizeGameQuit();
                return;
            }
            
            highScoreChecked = true;  // Mark that we've checked high scores
            
            if (highScoreManager.isHighScore(score)) {
                console.log('Qualifying high score detected:', score, 'Level:', currentLevel);
                // Show high score entry form
                highScoreManager.showHighScoreEntry(score, currentLevel, (submitted, rank) => {
                    if (submitted) {
                        console.log(`New high score submitted! Rank: ${rank}`);
                        // Optionally show the high scores table
                        setTimeout(() => {
                            highScoreManager.showHighScores(() => {
                                finalizeGameQuit();
                            });
                        }, 500);
                    } else {
                        finalizeGameQuit();
                    }
                });
            } else {
                console.log('Score does not qualify for high scores:', score);
                finalizeGameQuit();
            }
        }
        
        // Finalize the game quit process
        function finalizeGameQuit() {
            gameQuit = true;
            paused = false; // Make sure the starfield keeps moving
        }
        
        // Handle player death
        function handlePlayerDeath() {
            playerLives--;
            createExplosion(player.x + player.width / 2, player.y + player.height / 2);
            soundManager.playExplosionSound();
            
            if (playerLives <= 0) {
                checkForHighScore();
                return;
            }
            
            // Respawn player
            player.x = player.respawnX;
            player.y = player.respawnY;
            player.velocityX = 0;  // Reset x velocity on respawn
            player.velocityY = 0;  // Reset y velocity on respawn
            playerInvulnerable = true;
            playerInvulnerableTime = Date.now();
            
            // Clear bullets
            bullets.length = 0;
        }
    </script>
</body>
</html>
