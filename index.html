<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Defense</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="mainWrapper">
        <div id="infoPanel">
            <div id="infoTop">
                <span id="scoreValue">0</span> | <span id="levelName">1 Alpha</span>
            </div>
            <div id="progressContainer">
                <div id="progressLabel">Enemies Remaining: <span id="enemiesRemaining">30</span></div>
                <div id="progressBar">
                    <div id="progressFill"></div>
                </div>
            </div>
        </div>
        <div id="gameContainer" style="position: relative;">
            <canvas id="gameCanvas" width="600" height="800"></canvas>
            <div id="instructions">Arrow keys to move • Space to shoot • P or ESC to pause • R to restart • Q to quit • H for high scores</div>
            
            <!-- ===== TITLE CARD START ===== -->
            <div id="startOverlay">
                <div id="gameTitle">STELLAR DEFENSE</div>
                <button id="startButton">START GAME</button>
                <button id="viewHighScoresButton">HIGH SCORES</button>
            </div>
            <!-- ===== TITLE CARD END ===== -->
            
            <!-- ===== ENEMY INFO CARD START ===== -->
            <div id="enemyInfoOverlay">
                <div class="enemy-info-header">ENEMY TYPES</div>
                <div id="enemyInfoTable">
                    <!-- Table will be populated by JavaScript -->
                </div>
                <button id="startButtonEnemyPage">START GAME</button>
                <button id="viewHighScoresButtonEnemyPage">HIGH SCORES</button>
            </div>
            <!-- ===== ENEMY INFO CARD END ===== -->
            
            <!-- Game State Overlays -->
            <div id="pauseOverlay" class="game-overlay pause-overlay">
                <div class="main-text">PAUSED</div>
                <div class="sub-text">Press P or ESC to resume</div>
            </div>
            
            <div id="gameOverOverlay" class="game-overlay game-over-overlay">
                <div class="main-text">GAME OVER</div>
                <div class="score-text">Final Score: <span id="finalScore">000000</span></div>
                <div class="sub-text">Thanks for playing!</div>
                <div class="sub-text">Press R to restart</div>
                <div class="sub-text" id="titleReturnTimer">Returning to title screen in <span id="returnCountdown">5</span>...</div>
            </div>
            
            <div id="levelTransitionOverlay" class="game-overlay level-transition-overlay">
                <div class="main-text">LEVEL COMPLETE!</div>
                <div class="level-text"><span id="completedLevelName">Level Name</span> cleared!</div>
                <div class="score-text">Score: <span id="transitionScore">000000</span></div>
                <div class="sub-text">Loading next level...</div>
            </div>
            
            <div id="victoryOverlay" class="game-overlay victory-overlay">
                <div class="main-text">VICTORY!</div>
                <div class="score-text">Final Score: <span id="victoryScore">000000</span></div>
                <div class="sub-text">All levels completed!</div>
                <div class="sub-text">Press R to restart</div>
                <div class="sub-text" id="victoryReturnTimer">Returning to title screen in <span id="victoryCountdown">5</span>...</div>
            </div>
            
            <!-- High Score Entry Overlay -->
            <div id="highScoreEntryOverlay" class="game-overlay high-score-entry-overlay">
                <div class="main-text">NEW HIGH SCORE!</div>
                <div class="score-info">
                    Score: <span class="highlight" id="newHighScore">000000</span> | 
                    Level: <span class="highlight" id="newHighLevel">1</span>
                </div>
                <div class="name-input-container">
                    <label class="name-input-label" for="playerNameInput">Enter Your Name (8 characters max):</label>
                    <input type="text" id="playerNameInput" class="name-input" maxlength="8" placeholder="PLAYER">
                </div>
                <div class="high-score-buttons">
                    <button id="submitHighScore" class="high-score-btn primary">SUBMIT</button>
                    <button id="skipHighScore" class="high-score-btn">SKIP</button>
                </div>
            </div>
            
            <!-- High Scores Table Overlay -->
            <div id="highScoresOverlay" class="game-overlay high-scores-overlay">
                <div class="high-scores-header">HIGH SCORES</div>
                <div id="highScoresTable">
                    <!-- Table will be populated by JavaScript -->
                </div>
                <button id="closeHighScores" class="close-high-scores">CLOSE</button>
            </div>
        </div>
    </div>

    <script src="sound.js"></script>
    <script src="level_config.js"></script>
    <script src="visual_effects.js"></script>
    <script src="enemy_manager.js"></script>
    <script src="high_scores.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ===== TITLE CARD ELEMENTS =====
        const startOverlay = document.getElementById('startOverlay');
        const startButton = document.getElementById('startButton');
        
        // Initialize visual effects
        const visualEffects = new VisualEffects(canvas, ctx);
        
        // Initialize enemy manager
        const enemyManager = new EnemyManager(canvas, ctx, soundManager, visualEffects);
        
        // Initialize high score manager
        const highScoreManager = new HighScoreManager();
        
        // Game state
        const keys = {};
        let score = 0;
        let lastShot = 0;
        let shotsInBurst = 0;  // Track shots in current burst
        let lastBurstTime = 0; // Track when last burst started
        let canShoot = true;   // Track if we can shoot in current burst
        let paused = false;
        let enemiesDestroyed = 0;
        let totalEnemiesCreated = 0;
        let gameWon = false;
        let gameQuit = false;
        let levelTransition = false;
        let gameStartTime = 0; // Initialize to 0, will be set when game starts
        let currentLevel = 1;
        let debugMode = false;
        let playerLives = 3;
        let playerInvulnerable = false;
        let playerInvulnerableTime = 0;
        let gameStarted = false;
        let highScoreChecked = false;  // Prevent multiple high score checks
        
        // ===== TITLE CARD RETURN SYSTEM =====
        let gameOverStartTime = 0;     // When game over/victory screen was shown
        let gameOverDelay = 5000;      // 5 seconds delay before returning to title (adjustable)
        
        // Player shooting parameters
        let playerFireRate = 85; // ms between shots in a burst
        let playerBurstLength = 5; // shots per burst
        let playerBurstCooldown = 550; // ms cooldown between bursts
        
        // Extra life system
        const extraLifeThresholds = [10000, 21000, 44100, 92610];
        let extraLifeIndex = 0;  // Track which threshold is next
        
        // Pause timing system
        let pauseStartTime = 0;
        let totalPausedTime = 0;
        
        // Level teleport system for debug mode
        let teleportInput = '';
        let teleportActive = false;
        
        // Current level config
        let enemyConfig = levelConfigs[currentLevel];
        
        // Initialize enemy manager with level config
        enemyManager.initializeLevel(enemyConfig);
        
        // Player ship
        const player = {
            x: canvas.width / 2 - 9,
            y: canvas.height - 55,
            width: 18,
            height: 18,
            speed: 5,
            velocityX: 0,  // Current x velocity
            velocityY: 0,  // Current y velocity
            maxSpeedX: 5,  // Maximum x speed
            maxSpeedY: 5,  // Maximum y speed
            accelerationX: 0.15,  // X acceleration factor for ease-in
            accelerationY: 0.15,  // Y acceleration factor for ease-in (lower = more noticeable ease)
            frictionX: 0.75,  // X friction for smooth stop
            frictionY: 0.75,  // Y friction for smooth stop
            respawnX: canvas.width / 2 - 9,  // Store respawn position
            respawnY: canvas.height - 55
        };
        
        // Bullets array
        const bullets = [];
        
        // Enemy bullets array
        const enemyBullets = [];
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            // Initialize audio on first interaction
            if (!soundManager.audioContext) {
                soundManager.initAudio();
            }
            
            keys[e.code] = true;
            
            // Handle level teleport in debug mode
            if (debugMode && gameStarted && !paused) {
                if (e.key === 'j' && !teleportActive) {
                    // Start teleport input
                    teleportActive = true;
                    teleportInput = '';
                    console.log('Level teleport activated. Enter level number and press Enter...');
                    return;
                } else if (teleportActive) {
                    if (e.key === 'Enter') {
                        // Execute teleport
                        const targetLevel = parseInt(teleportInput);
                        if (!isNaN(targetLevel) && targetLevel > 0) {
                            teleportToLevel(targetLevel);
                        } else {
                            console.log('Invalid level number:', teleportInput);
                        }
                        teleportActive = false;
                        teleportInput = '';
                        return;
                    } else if (e.key === 'Escape') {
                        // Cancel teleport
                        console.log('Level teleport cancelled');
                        teleportActive = false;
                        teleportInput = '';
                        return;
                    } else if (e.key >= '0' && e.key <= '9') {
                        // Add digit to teleport input
                        teleportInput += e.key;
                        console.log('Teleport target:', teleportInput);
                        return;
                    } else if (e.key === 'Backspace') {
                        // Remove last digit
                        teleportInput = teleportInput.slice(0, -1);
                        console.log('Teleport target:', teleportInput || '(empty)');
                        return;
                    }
                    // For any other key during teleport input, ignore but don't cancel
                    return;
                }
            }
            
            if (e.code === 'KeyP' || e.code === 'Escape') {
                // Cancel teleport if escape is pressed
                if (teleportActive) {
                    console.log('Level teleport cancelled');
                    teleportActive = false;
                    teleportInput = '';
                    return;
                }
                
                // Handle pause/unpause with timing
                if (!paused) {
                    // Pausing the game
                    paused = true;
                    pauseStartTime = Date.now();
                } else {
                    // Unpausing the game
                    paused = false;
                    if (pauseStartTime > 0) {
                        totalPausedTime += Date.now() - pauseStartTime;
                        pauseStartTime = 0;
                    }
                }
            }
            
            if (e.code === 'KeyR') {
                restartGame();
            }
            
            if (e.code === 'KeyQ') {
                quitGame();
            }
            
            if (e.code === 'KeyD') {
                debugMode = !debugMode;  // Toggle debug mode
                if (debugMode) {
                    console.log('Debug mode enabled. Press j<levelnumber><enter> to teleport to a level');
                } else {
                    console.log('Debug mode disabled');
                    // Cancel any active teleport input
                    teleportActive = false;
                    teleportInput = '';
                }
            }
            
            if (e.code === 'KeyH') {
                highScoreManager.showHighScores();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Enhanced collision check that handles both rectangular and circular collision
        function checkEnhancedCollision(obj1, obj2) {
            // Check if either object is a type 4 enemy (circular collision)
            const obj1IsType4 = obj1.type === 4;
            const obj2IsType4 = obj2.type === 4;
            
            if (obj1IsType4 && !obj2IsType4) {
                return enemyManager.checkCircularCollision(obj1, obj2);
            } else if (obj2IsType4 && !obj1IsType4) {
                return enemyManager.checkCircularCollision(obj2, obj1);
            } else if (obj1IsType4 && obj2IsType4) {
                // Both are type 4, use circle-to-circle collision
                const center1X = obj1.x + obj1.width / 2;
                const center1Y = obj1.y + obj1.height / 2;
                const radius1 = obj1.width / 2;
                
                const center2X = obj2.x + obj2.width / 2;
                const center2Y = obj2.y + obj2.height / 2;
                const radius2 = obj2.width / 2;
                
                const dx = center1X - center2X;
                const dy = center1Y - center2Y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance < (radius1 + radius2);
            } else {
                // Neither is type 4, use regular rectangular collision
                return enemyManager.checkCollision(obj1, obj2);
            }
        }
        
        // Create explosion effect
        function createExplosion(x, y) {
            visualEffects.createExplosion(x, y, soundManager);
        }
        
        // Update score display
        function updateScore(points) {
            const oldScore = score;
            score += points;
            document.getElementById('scoreValue').textContent = score.toString().padStart(6, '0');
            
            // Check for extra life thresholds
            if (extraLifeIndex < extraLifeThresholds.length) {
                const threshold = extraLifeThresholds[extraLifeIndex];
                if (oldScore < threshold && score >= threshold) {
                    // Award extra life
                    playerLives++;
                    extraLifeIndex++;
                    
                    // Visual and audio feedback
                    console.log(`Extra life earned at ${threshold} points! Lives: ${playerLives}`);
                    soundManager.playSpawnSound(); // Use spawn sound for extra life (positive sound)
                    
                    // Could add a visual effect here later
                    createExplosion(player.x + player.width / 2, player.y + player.height / 2); // Temporary visual effect
                }
            }
        }
        
        // Update level display
        function updateLevelDisplay() {
            document.getElementById('levelName').textContent = enemyConfig.name;
        }
        
        // Update progress bar display
        function updateProgressBar() {
            const remaining = enemyManager.getSpawnScheduleInfo().totalScheduled - enemiesDestroyed;
            const progressPercentage = (enemiesDestroyed / enemyManager.getSpawnScheduleInfo().totalScheduled) * 100;
            
            document.getElementById('enemiesRemaining').textContent = remaining;
            document.getElementById('progressFill').style.width = progressPercentage + '%';
        }
        
        // Restart game function
        function restartGame() {
            // Stop all active tractor beam sounds
            soundManager.stopAllTractorBeams();
            
            score = 0;
            enemiesDestroyed = 0;
            totalEnemiesCreated = 0;
            gameWon = false;
            gameQuit = false;
            levelTransition = false;
            paused = false;
            currentLevel = 1;
            playerLives = 3;
            playerInvulnerable = false;
            gameStarted = true;  // Make sure the game is marked as started
            gameStartTime = Date.now();
            highScoreChecked = false;  // Reset high score check flag
            
            // Reset pause timing
            pauseStartTime = 0;
            totalPausedTime = 0;
            
            // Reset extra life tracking
            extraLifeIndex = 0;
            
            // Reset title card return system
            gameOverStartTime = 0;
            
            enemyConfig = levelConfigs[currentLevel];
            
            // Initialize enemy manager with level config
            enemyManager.initializeLevel(enemyConfig);
            
            // Update visual effects level
            visualEffects.setCurrentLevel(currentLevel);
            
            document.getElementById('scoreValue').textContent = score.toString().padStart(6, '0');
            updateLevelDisplay();
            updateProgressBar();
            
            player.x = player.respawnX;
            player.y = player.respawnY;
            
            bullets.length = 0;
            enemyBullets.length = 0;
            visualEffects.explosions.length = 0;
            
            // Hide title card and all overlays when restarting
            startOverlay.style.display = 'none';
            visualEffects.hideAllOverlays();
        }
        
        // Advance to next level
        function nextLevel() {
            // Stop all active tractor beam sounds when transitioning levels
            soundManager.stopAllTractorBeams();
            
            currentLevel++;
            if (levelConfigs[currentLevel]) {
                enemyConfig = levelConfigs[currentLevel];
                
                // Initialize enemy manager with level config
                enemyManager.initializeLevel(enemyConfig);
                
                enemiesDestroyed = 0;
                totalEnemiesCreated = 0;
                gameWon = false;
                levelTransition = false;
                gameStartTime = Date.now();
                
                // Reset pause timing for new level
                pauseStartTime = 0;
                totalPausedTime = 0;
                
                // Update visual effects level
                visualEffects.setCurrentLevel(currentLevel);
                
                updateLevelDisplay();
                updateProgressBar();
                
                bullets.length = 0;
                enemyBullets.length = 0;
                visualEffects.explosions.length = 0;
            } else {
                gameWon = true;
                levelTransition = false;
            }
        }
        
        // Teleport to specific level (debug function)
        function teleportToLevel(targetLevel) {
            if (!debugMode) return; // Only allow in debug mode
            
            if (levelConfigs[targetLevel]) {
                currentLevel = targetLevel;
                enemyConfig = levelConfigs[currentLevel];
                
                // Initialize enemy manager with level config
                enemyManager.initializeLevel(enemyConfig);
                
                enemiesDestroyed = 0;
                totalEnemiesCreated = 0;
                gameWon = false;
                levelTransition = false;
                gameStartTime = Date.now();
                
                // Reset pause timing for teleported level
                pauseStartTime = 0;
                totalPausedTime = 0;
                
                // Update visual effects level
                visualEffects.setCurrentLevel(currentLevel);
                
                updateLevelDisplay();
                updateProgressBar();
                
                bullets.length = 0;
                enemyBullets.length = 0;
                visualEffects.explosions.length = 0;
                
                console.log(`Teleported to level ${targetLevel}: ${enemyConfig.name}`);
            } else {
                console.log(`Level ${targetLevel} does not exist`);
            }
        }
        
        // Shoot bullet
        function shootBullet() {
            const now = Date.now();
            
            // Reset burst if player hasn't fired for 2 seconds
            if (now - lastShot > 2000) {
                shotsInBurst = 0;
                canShoot = true;
            }
            
            // If we're in cooldown, check if it's been long enough
            if (shotsInBurst >= playerBurstLength) {
                if (now - lastBurstTime < playerBurstCooldown) { // Use new state variable
                    return;
                }
                // Reset burst if cooldown is over
                shotsInBurst = 0;
                canShoot = true;
            }
            
            // Only shoot if we're allowed to in this burst
            if (!canShoot) {
                return;
            }
            
            // Add delay between individual bullets in burst (use new state variable)
            if (shotsInBurst > 0 && now - lastShot < playerFireRate) {
                return;
            }
            
            bullets.push({
                x: player.x + player.width / 2 - 1,
                y: player.y,
                width: 2,
                height: 6,
                speed: 8
            });
            
            soundManager.playBulletSound();
            shotsInBurst++;
            lastShot = now;
            
            // If we've used all shots, start cooldown timer and prevent further shooting
            if (shotsInBurst >= playerBurstLength) { // Use new state variable
                canShoot = false;
                lastBurstTime = now;  // Start cooldown timer when burst completes
            }
        }
        
        // Update game state
        function update() {
            // Always update starfield for attract screen effect
            visualEffects.updateStarfield();
            
            // ===== TITLE CARD RETURN SYSTEM =====
            // Check if we should return to title screen after delay (game over or victory)
            if ((gameQuit || gameWon) && gameOverStartTime > 0) {
                const timeOnScreen = Date.now() - gameOverStartTime;
                const timeRemaining = Math.max(0, gameOverDelay - timeOnScreen);
                const secondsRemaining = Math.ceil(timeRemaining / 1000);
                
                // Update countdown display for both game over and victory
                const gameOverCountdown = document.getElementById('returnCountdown');
                const victoryCountdown = document.getElementById('victoryCountdown');
                
                if (gameOverCountdown) {
                    gameOverCountdown.textContent = secondsRemaining;
                }
                if (victoryCountdown) {
                    victoryCountdown.textContent = secondsRemaining;
                }
                
                if (timeOnScreen >= gameOverDelay) {
                    returnToTitleScreen();
                    return;
                }
            }
            
            if (!gameStarted || paused || gameWon || levelTransition) return;
            
            // If game is quit, only update starfield (already done above)
            if (gameQuit) {
                return;
            }
            
            enemyManager.spawnEnemies(gameStartTime, totalPausedTime);
            
            // Handle player invulnerability
            if (playerInvulnerable) {
                const now = Date.now();
                if (now - playerInvulnerableTime > 2000) { // 2 seconds of invulnerability
                    playerInvulnerable = false;
                }
            }
            
            // Player Movement Logic (Restored/Ensured)
            // Horizontal movement with ease-in
            let targetVelocityX = 0;
            if (keys['ArrowLeft'] && player.x > 0) {
                targetVelocityX = -player.maxSpeedX;
            }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
                targetVelocityX = player.maxSpeedX;
            }
            
            // Apply easing to x velocity
            if (targetVelocityX !== 0) {
                // Accelerate towards target velocity
                player.velocityX += (targetVelocityX - player.velocityX) * player.accelerationX;
            } else {
                // Apply friction when no input
                player.velocityX *= player.frictionX;
            }
            
            // Apply velocity to position
            player.x += player.velocityX;
            
            // Vertical movement with ease-in
            let targetVelocityY = 0;
            if (keys['ArrowUp'] && player.y > canvas.height / 2) {
                targetVelocityY = -player.maxSpeedY;
            }
            if (keys['ArrowDown'] && player.y < canvas.height - player.height) {
                targetVelocityY = player.maxSpeedY;
            }
            
            // Apply easing to y velocity
            if (targetVelocityY !== 0) {
                // Accelerate towards target velocity
                player.velocityY += (targetVelocityY - player.velocityY) * player.accelerationY;
            } else {
                // Apply friction when no input
                player.velocityY *= player.frictionY;
            }
            
            // Apply velocity to position
            player.y += player.velocityY;
            // End of Player Movement Logic
            
            const now = Date.now();
            if (keys['Space']) {
                shootBullet();
            }
            
            // Call enemyManager to update enemies
            enemyManager.updateEnemies(player, enemyBullets);
            
            // Check for player collision with enemies AFTER enemyManager update
            const currentEnemies = enemyManager.getEnemies();
            for (let i = currentEnemies.length - 1; i >= 0; i--) {
                const enemy = currentEnemies[i];
                if (enemy.alive && !playerInvulnerable && checkEnhancedCollision(player, enemy)) {
                    handlePlayerDeath();
                    break; // Player can only die once per frame
                }
            }
            
            for (let i = bullets.length - 1; i >= 0; i--) {
                // Handle deflected bullets with different movement
                if (bullets[i].deflected && bullets[i].vx !== undefined && bullets[i].vy !== undefined) {
                    bullets[i].x += bullets[i].vx;
                    bullets[i].y += bullets[i].vy;
                } else {
                    bullets[i].y -= bullets[i].speed;
                }
                
                let bulletHit = false;
                for (let j = currentEnemies.length - 1; j >= 0; j--) { // Use currentEnemies from enemyManager
                    const enemy = currentEnemies[j]; // Use currentEnemies
                    if (enemy.alive && checkEnhancedCollision(bullets[i], enemy)) {
                        // Check if this is a type 4 enemy with active force field
                        if (enemy.type === 4 && enemy.forceField && enemy.forceField.active) {
                            // Deflect bullet instead of destroying enemy
                            const bulletCenterX = bullets[i].x + bullets[i].width / 2;
                            const bulletCenterY = bullets[i].y + bullets[i].height / 2;
                            const enemyCenterX = enemy.x + enemy.width / 2;
                            const enemyCenterY = enemy.y + enemy.height / 2;
                            
                            // Calculate deflection angle
                            const dx = bulletCenterX - enemyCenterX;
                            const dy = bulletCenterY - enemyCenterY;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            
                            if (length > 0) {
                                // Deflect bullet away from enemy center
                                const deflectionSpeed = 6;
                                bullets[i].vx = (dx / length) * deflectionSpeed;
                                bullets[i].vy = (dy / length) * deflectionSpeed;
                                bullets[i].deflected = true; // Mark as deflected to change behavior
                            }
                            
                            // Create small visual effect for deflection
                            for (let k = 0; k < 3; k++) {
                                visualEffects.explosions.push({
                                    x: bulletCenterX,
                                    y: bulletCenterY,
                                    vx: (Math.random() - 0.5) * 2,
                                    vy: (Math.random() - 0.5) * 2,
                                    life: 15,
                                    maxLife: 15
                                });
                            }
                            
                            break; // Don't destroy the bullet or enemy
                        } else {
                            // Normal collision - destroy enemy
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            // Get points using enemy manager (includes score bonus)
                            const basePoints = enemyManager.getEnemyBaseConfig()[`type${enemy.type}`]?.points || enemyManager.getEnemyBaseConfig().type1.points;
                            const scoreBonus = enemyConfig.global.scoreBonus || 0;
                            const points = basePoints + scoreBonus;
                            
                            updateScore(points);
                            enemy.alive = false;
                            enemiesDestroyed++;
                            updateProgressBar();
                            bullets.splice(i, 1);
                            bulletHit = true;
                            
                            if (enemiesDestroyed >= enemyManager.getSpawnScheduleInfo().totalScheduled) {
                                if (levelConfigs[currentLevel + 1]) {
                                    // Start level transition
                                    levelTransition = true;
                                    setTimeout(nextLevel, 2500); // 2.5 second pause
                                } else {
                                    // All levels complete - true victory
                                    gameWon = true;
                                }
                            }
                            
                            break;
                        }
                    }
                }
                
                if (bulletHit) {
                    continue; // If bullet hit an enemy, skip further processing for this bullet index.
                }
                
                // Remove bullets that go off screen (normal bullets only go up, deflected can go anywhere)
                // Ensure bullets[i] still exists before accessing its properties, as it might have been spliced.
                if (bullets[i]) { 
                    if (bullets[i].deflected) {
                        if (bullets[i].x < -10 || bullets[i].x > canvas.width + 10 || 
                            bullets[i].y < -10 || bullets[i].y > canvas.height + 10) {
                            bullets.splice(i, 1);
                        }
                    } else {
                        if (bullets[i].y < 0) {
                            bullets.splice(i, 1);
                        }
                    }
                }
            }
            
            // Update enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                // Check collision with player
                if (!playerInvulnerable && checkEnhancedCollision(bullet, player)) {
                    handlePlayerDeath();
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                // Remove bullet if it goes off screen
                if (bullet.x < -10 || bullet.x > canvas.width + 10 || 
                    bullet.y < -10 || bullet.y > canvas.height + 10) {
                    enemyBullets.splice(i, 1);
                }
            }
            
            // Update visual effects
            visualEffects.updateExplosions();
        }
        
        // Draw everything
        function draw() {
            // Always clear screen and draw starfield (including on title screen)
            visualEffects.clearScreen();
            visualEffects.drawStarfield();
            
            // If still on title screen, just show starfield and return
            if (!gameStarted) {
                return;
            }
            
            // If game is quit, only show starfield and game over text
            if (gameQuit) {
                visualEffects.showOverlay('gameOver', { score });
                return;
            }
            
            // Level transition screen
            if (levelTransition) {
                visualEffects.showOverlay('levelTransition', { 
                    levelName: enemyConfig.name, 
                    score 
                });
                return;
            }
            
            // Draw game objects
            visualEffects.drawPlayer(player, playerInvulnerable);
            visualEffects.drawPlayerLives(playerLives);
            visualEffects.drawEnemies(enemyManager.getEnemies());
            visualEffects.drawBullets(bullets);
            visualEffects.drawEnemyBullets(enemyBullets);
            visualEffects.drawExplosions();
            
            // Only show debug info if debug mode is enabled
            if (debugMode) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'left';
                const aliveEnemies = enemyManager.getEnemies().filter(e => e.alive).length;
                const remainingToKill = enemyManager.getSpawnScheduleInfo().totalScheduled - enemiesDestroyed;
                const currentTime = (Date.now() - gameStartTime - totalPausedTime) / 1000;
                const timeWindow = enemyConfig.global.spawnTimeWindow;
                
                let debugY = canvas.height - 90;
                
                // Show teleport status if active
                if (teleportActive) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(`TELEPORT: j${teleportInput}_ (Enter to confirm, Esc to cancel)`, 10, debugY);
                    debugY += 15;
                    ctx.fillStyle = '#ffffff';
                }
                
                ctx.fillText(`DEBUG: Spawned: ${enemyManager.getTotalEnemiesCreated()}/${enemyManager.getSpawnScheduleInfo().totalScheduled}`, 10, debugY);
                ctx.fillText(`Schedule: ${enemyManager.getSpawnScheduleInfo().nextSpawnIndex}/${enemyManager.getSpawnScheduleInfo().totalScheduled} | Time: ${currentTime.toFixed(1)}s/${timeWindow}s`, 10, debugY + 15);
                ctx.fillText(`Alive: ${aliveEnemies} | Killed: ${enemiesDestroyed}`, 10, debugY + 30);
                ctx.fillText(`Remaining: ${remainingToKill}`, 10, debugY + 45);
                ctx.fillText(`Total Enemies Array (Manager): ${enemyManager.getEnemies().length}`, 10, debugY + 60);
                ctx.fillText(`Level: ${currentLevel} (${enemyConfig.name}) | j<num><enter> to teleport`, 10, debugY + 75);
                
                // Show force field status for type 4 enemies
                const type4Enemies = enemyManager.getEnemies().filter(e => e.alive && e.type === 4);
                if (type4Enemies.length > 0) {
                    const activeForceFields = [];
                    type4Enemies.forEach((enemy, index) => {
                        if (enemy.forceField && enemy.forceField.active) {
                            const timeRemaining = Math.max(0, enemy.forceField.duration - (Date.now() - enemy.forceField.activationStartTime)) / 1000;
                            activeForceFields.push(`#${enemyManager.getEnemies().indexOf(enemy)} (${timeRemaining.toFixed(1)}s)`);
                        }
                    });
                    
                    if (activeForceFields.length > 0) {
                        ctx.fillStyle = '#00ffff'; // Cyan color for force field info
                        ctx.fillText(`Force Fields Active: ${activeForceFields.join(', ')}`, 10, debugY + 90);
                        ctx.fillStyle = '#ffffff'; // Reset to white
                    } else {
                        ctx.fillStyle = '#888888'; // Gray for inactive
                        ctx.fillText(`Force Fields: None active (${type4Enemies.length} type-4 enemies present)`, 10, debugY + 90);
                        ctx.fillStyle = '#ffffff'; // Reset to white
                    }
                }
            }
            
            // Show overlay screens
            if (paused) {
                visualEffects.showOverlay('paused');
            } else if (gameWon) {
                visualEffects.showOverlay('victory', { score });
                // Also start return timer for victory screen
                if (gameOverStartTime === 0) {
                    gameOverStartTime = Date.now();
                }
            } else if (!gameQuit && !levelTransition) {
                // Hide overlays when game is running normally
                visualEffects.hideAllOverlays();
            }
        }
        
        // Main game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        
        // ===== ATTRACT SCREEN SYSTEM =====
        
        // Attract screen elements
        const enemyInfoOverlay = document.getElementById('enemyInfoOverlay');
        const startButtonEnemyPage = document.getElementById('startButtonEnemyPage');
        const viewHighScoresButtonEnemyPage = document.getElementById('viewHighScoresButtonEnemyPage');
        
        // Attract screen state
        let attractScreenTimer = null;
        let currentAttractPage = 'title'; // 'title' or 'enemyInfo'
        const attractPageDuration = 10000; // 10 seconds per page
        
        // Enemy type descriptions
        const enemyDescriptions = {
            1: { sprite: 'enemy_type1.png', behavior: 'Basic' },
            2: { sprite: 'enemy_type2.png', behavior: 'Erratic' },
            3: { sprite: 'enemy_type3.png', behavior: 'Moderate' },
            4: { sprite: 'enemy_type4.png', behavior: 'Shield' },
            5: { sprite: 'enemy_type5.png', behavior: 'Shooter' },
            6: { sprite: 'enemy_type6.png', behavior: 'Retrograde' },
            7: { sprite: 'enemy_type7.png', behavior: 'Balanced' },
            8: { sprite: 'enemy_type8.png', behavior: 'Tractor' }
        };
        
        // Initialize enemy info table
        function initializeEnemyInfoTable() {
            const enemyConfig = enemyManager.getEnemyBaseConfig();
            const tableContainer = document.getElementById('enemyInfoTable');
            
            let tableHTML = `
                <table class="enemy-info-table">
                    <thead>
                        <tr>
                            <th class="enemy-type">Type</th>
                            <th class="enemy-sprite">Enemy</th>
                            <th class="enemy-points">Points</th>
                            <th class="enemy-behavior">Ability</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Add each enemy type
            for (let i = 1; i <= 8; i++) {
                const config = enemyConfig[`type${i}`];
                const description = enemyDescriptions[i];
                if (config && description) {
                    tableHTML += `
                        <tr>
                            <td class="enemy-type">${i}</td>
                            <td class="enemy-sprite"><img src="${description.sprite}" alt="Enemy Type ${i}" class="enemy-sprite-img"></td>
                            <td class="enemy-points">${config.points}</td>
                            <td class="enemy-behavior">${description.behavior}</td>
                        </tr>
                    `;
                }
            }
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            tableContainer.innerHTML = tableHTML;
        }
        
        // Reset animations for elements
        function resetPageAnimations(pageType) {
            if (pageType === 'title') {
                const title = document.getElementById('gameTitle');
                const startBtn = document.getElementById('startButton');
                const highScoreBtn = document.getElementById('viewHighScoresButton');
                
                // Reset animations
                title.classList.add('reset-animation');
                startBtn.classList.add('reset-button-animation');
                highScoreBtn.classList.add('reset-button-animation');
                
                // Restart animations after a brief delay
                setTimeout(() => {
                    title.classList.remove('reset-animation');
                    title.classList.add('restart-animation');
                    startBtn.classList.remove('reset-button-animation');
                    startBtn.classList.add('restart-button-animation');
                    highScoreBtn.classList.remove('reset-button-animation');
                    highScoreBtn.classList.add('restart-button-animation', 'delay-200');
                }, 50);
                
                // Clean up classes after animations complete
                setTimeout(() => {
                    title.classList.remove('restart-animation');
                    startBtn.classList.remove('restart-button-animation');
                    highScoreBtn.classList.remove('restart-button-animation', 'delay-200');
                }, 4000);
                         } else if (pageType === 'enemyInfo') {
                const header = document.querySelector('.enemy-info-header');
                
                // Reset animations for header only (buttons don't animate on this page)
                header.classList.add('reset-animation');
                
                // Restart header animation after a brief delay
                setTimeout(() => {
                    header.classList.remove('reset-animation');
                    header.classList.add('restart-animation');
                }, 50);
                
                // Clean up classes after animation completes
                setTimeout(() => {
                    header.classList.remove('restart-animation');
                }, 4000);
            }
        }
        
        // Switch between attract screen pages
        function switchAttractPage() {
            if (gameStarted) return; // Don't switch if game has started
            
            if (currentAttractPage === 'title') {
                // Switch to enemy info page
                startOverlay.style.display = 'none';
                enemyInfoOverlay.style.display = 'flex';
                currentAttractPage = 'enemyInfo';
                resetPageAnimations('enemyInfo');
            } else {
                // Switch to title page
                enemyInfoOverlay.style.display = 'none';
                startOverlay.style.display = 'flex';
                currentAttractPage = 'title';
                resetPageAnimations('title');
            }
            
            // Schedule next switch
            if (attractScreenTimer) {
                clearTimeout(attractScreenTimer);
            }
            attractScreenTimer = setTimeout(switchAttractPage, attractPageDuration);
        }
        
        // Start attract screen cycling
        function startAttractScreenCycling() {
            if (gameStarted) return;
            
            // Start with title page
            currentAttractPage = 'title';
            startOverlay.style.display = 'flex';
            enemyInfoOverlay.style.display = 'none';
            
            // Schedule first switch to enemy info
            attractScreenTimer = setTimeout(switchAttractPage, attractPageDuration);
        }
        
        // Stop attract screen cycling
        function stopAttractScreenCycling() {
            if (attractScreenTimer) {
                clearTimeout(attractScreenTimer);
                attractScreenTimer = null;
            }
        }
        
        // ===== TITLE CARD EVENT HANDLERS START =====
        
        // Initialize game on start button click (both pages)
        function initializeGame() {
            if (!soundManager.audioContext) {
                soundManager.initAudio();
            }
            stopAttractScreenCycling();
            startOverlay.style.display = 'none';
            enemyInfoOverlay.style.display = 'none';
            gameStarted = true;
            
            // Initialize game timing and spawn schedule when game actually starts
            gameStartTime = Date.now();
        }
        
        startButton.addEventListener('click', initializeGame);
        startButtonEnemyPage.addEventListener('click', initializeGame);
        
        // High scores button click (both pages)
        function showHighScoresFromAttract() {
            stopAttractScreenCycling();
            startOverlay.style.display = 'none';
            enemyInfoOverlay.style.display = 'none';
            
            highScoreManager.showHighScores(() => {
                // Resume attract screen cycling when high scores are closed
                if (!gameStarted) {
                    startAttractScreenCycling();
                }
            });
        }
        
        document.getElementById('viewHighScoresButton').addEventListener('click', showHighScoresFromAttract);
        viewHighScoresButtonEnemyPage.addEventListener('click', showHighScoresFromAttract);

        
        // ===== TITLE CARD EVENT HANDLERS END =====
        
        // ===== TITLE CARD RETURN FUNCTION =====
        function returnToTitleScreen() {
            // Stop all active tractor beam sounds
            soundManager.stopAllTractorBeams();
            
            // Reset all game state to initial values
            gameStarted = false;
            gameQuit = false;
            gameWon = false;
            paused = false;
            levelTransition = false;
            highScoreChecked = false;
            score = 0;
            enemiesDestroyed = 0;
            totalEnemiesCreated = 0;
            currentLevel = 1;
            playerLives = 3;
            playerInvulnerable = false;
            gameOverStartTime = 0;
            
            // Reset pause timing
            pauseStartTime = 0;
            totalPausedTime = 0;
            
            // Reset extra life tracking
            extraLifeIndex = 0;
            
            // Reset level config
            enemyConfig = levelConfigs[currentLevel];
            
            // Initialize enemy manager with level config
            enemyManager.initializeLevel(enemyConfig);
            
            // Update visual effects level
            visualEffects.setCurrentLevel(currentLevel);
            
            // Reset player position
            player.x = player.respawnX;
            player.y = player.respawnY;
            player.velocityX = 0;
            player.velocityY = 0;
            
            // Clear all arrays
            bullets.length = 0;
            enemyBullets.length = 0;
            visualEffects.explosions.length = 0;
            
            // Update displays
            document.getElementById('scoreValue').textContent = score.toString().padStart(6, '0');
            updateLevelDisplay();
            updateProgressBar();
            
            // Hide all overlays and start attract screen cycling
            visualEffects.hideAllOverlays();
            startAttractScreenCycling();
            
            console.log('Returned to title screen');
        }
        
        updateLevelDisplay();
        updateProgressBar();
        
        // Initialize attract screen system
        initializeEnemyInfoTable();
        startAttractScreenCycling();
        
        gameLoop();
        
        // Quit game function
        function quitGame() {
            const confirmed = confirm('Are you sure you want to quit the game?');
            if (confirmed) {
                checkForHighScore();
            }
        }
        
        // Check if current score qualifies for high score table
        function checkForHighScore() {
            // Prevent multiple high score checks in the same game session
            if (highScoreChecked) {
                finalizeGameQuit();
                return;
            }
            
            highScoreChecked = true;  // Mark that we've checked high scores
            
            if (highScoreManager.isHighScore(score)) {
                console.log('Qualifying high score detected:', score, 'Level:', currentLevel);
                // Show high score entry form
                highScoreManager.showHighScoreEntry(score, currentLevel, (submitted, rank) => {
                    if (submitted) {
                        console.log(`New high score submitted! Rank: ${rank}`);
                        // Optionally show the high scores table
                        setTimeout(() => {
                            highScoreManager.showHighScores(() => {
                                finalizeGameQuit();
                            });
                        }, 500);
                    } else {
                        finalizeGameQuit();
                    }
                });
            } else {
                console.log('Score does not qualify for high scores:', score);
                finalizeGameQuit();
            }
        }
        
        // Finalize the game quit process
        function finalizeGameQuit() {
            // Stop all active tractor beam sounds
            soundManager.stopAllTractorBeams();
            
            gameQuit = true;
            paused = false; // Make sure the starfield keeps moving
            gameOverStartTime = Date.now(); // Start the timer for returning to title
        }
        
        // Handle player death
        function handlePlayerDeath() {
            playerLives--;
            createExplosion(player.x + player.width / 2, player.y + player.height / 2);
            soundManager.playExplosionSound();
            
            if (playerLives <= 0) {
                checkForHighScore();
                return;
            }
            
            // Respawn player
            player.x = player.respawnX;
            player.y = player.respawnY;
            player.velocityX = 0;  // Reset x velocity on respawn
            player.velocityY = 0;  // Reset y velocity on respawn
            playerInvulnerable = true;
            playerInvulnerableTime = Date.now();
            
            // Clear bullets
            bullets.length = 0;
        }
    </script>
</body>
</html>
